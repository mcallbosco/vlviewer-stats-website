<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VLViewer Stats Website</title>
  <meta name="description" content="Track character plays over time across configs" />
  <link rel="icon" href="auto/deadlock-deadlockaugust22025/icon.png" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind config to get a dark style similar vibe
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50: '#f2f6ff',
              100: '#dde7ff',
              200: '#b6c8ff',
              300: '#8fa8ff',
              400: '#6d8fff',
              500: '#4a76ff',
              600: '#335de6',
              700: '#2949b4',
              800: '#213a8c',
              900: '#1a2e6e'
            }
          }
        }
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-800 text-slate-100">
  <header class="border-b border-white/10 bg-slate-900/50 backdrop-blur sticky top-0 z-10">
    <div class="max-w-6xl mx-auto px-4 py-4 flex items-center gap-3">
      <img id="configIcon" src="auto/deadlock-deadlockaugust22025/icon.png" alt="Config Icon" class="h-8 w-8 rounded" />
      <h1 class="text-xl font-semibold tracking-wide">VLViewer Stats</h1>
      <span class="ml-auto text-xs text-slate-400">Static prototype</span>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6">
    <section class="mb-4 grid grid-cols-1 md:grid-cols-4 gap-3">
      <div class="col-span-2 bg-slate-900/60 border border-white/10 rounded-lg p-4">
        <label for="configSelect" class="block text-sm mb-1 text-slate-300">Select Config</label>
        <select id="configSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500"></select>
        <p id="configMeta" class="mt-2 text-xs text-slate-400"></p>
      </div>
      <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
        <label for="dataTypeSelect" class="block text-sm mb-1 text-slate-300">Data Type</label>
        <select id="dataTypeSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
          <option value="character_totals_deltas">Characters</option>
          <option value="voicelines_deltas">Voicelines</option>
          <option value="conversations_deltas">Conversations</option>
        </select>
        <p class="mt-2 text-xs text-slate-400">Select type of data to view.</p>
      </div>
      <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
        <label for="viewMode" class="block text-sm mb-1 text-slate-300">View Mode</label>
        <select id="viewMode" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
          <option value="single">Single Item</option>
          <option value="all">All Items</option>
          <option value="allLines">All Items (Lines)</option>
          <option value="slope">Slope Chart (Trends)</option>
          <option value="pie">Market Share (Pie)</option>
          <option value="comparison">Compare Items</option>
        </select>
        <p class="mt-2 text-xs text-slate-400">Choose how to visualize the data.</p>
      </div>
    </section>

    <section id="statsPanel" class="mb-4 hidden">
      <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Total Items</div>
          <div id="statTotalChars" class="text-2xl font-bold text-brand-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Total Plays</div>
          <div id="statTotalPlays" class="text-2xl font-bold text-brand-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Most Popular</div>
          <div id="statMostPopular" class="text-sm font-bold text-green-400 truncate">-</div>
          <div id="statMostPopularValue" class="text-xs text-slate-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Fastest Growing</div>
          <div id="statFastestGrowing" class="text-sm font-bold text-purple-400 truncate">-</div>
          <div id="statFastestGrowingValue" class="text-xs text-slate-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Avg per Item</div>
          <div id="statAvgPlays" class="text-2xl font-bold text-brand-400">-</div>
        </div>
      </div>
    </section>

    <section id="comparisonSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4 hidden">
      <label class="block text-sm mb-2 text-slate-300">Select Items to Compare (hold Ctrl/Cmd for multiple)</label>
      <select id="comparisonSelect" multiple size="6" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
      </select>
      <p class="mt-2 text-xs text-slate-400">Select 2-6 items to compare their trends.</p>
    </section>

    <section id="topNSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4 hidden">
      <label for="topNSelect" class="block text-sm mb-1 text-slate-300">Show Top N Items</label>
      <select id="topNSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
        <option value="0">All Items</option>
        <option value="5">Top 5</option>
        <option value="10" selected>Top 10</option>
        <option value="15">Top 15</option>
        <option value="20">Top 20</option>
      </select>
      <p class="mt-2 text-xs text-slate-400">Filter to show only the most popular items.</p>
    </section>

    <section id="singleCharacterSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4">
      <label for="characterSelect" class="block text-sm mb-1 text-slate-300">Select Item</label>
      <select id="characterSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500" disabled>
        <option>Loading…</option>
      </select>
      <p id="characterHint" class="mt-2 text-xs text-slate-400">Choose a config to load characters.</p>
    </section>

    <section id="dateRangeSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
        <div>
          <label for="startDate" class="block text-sm mb-1 text-slate-300">Start Date</label>
          <input type="date" id="startDate" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500" />
        </div>
        <div>
          <label for="endDate" class="block text-sm mb-1 text-slate-300">End Date</label>
          <input type="date" id="endDate" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500" />
        </div>
        <div class="flex items-end">
          <button id="resetDateRange" class="w-full bg-slate-800 hover:bg-slate-700 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500 transition-colors">
            Reset Range
          </button>
        </div>
      </div>
      <div class="mt-3">
        <label for="granularitySlider" class="block text-sm mb-2 text-slate-300">
          Data Granularity: <span id="granularityLabel" class="text-brand-400 font-mono">30 min</span>
        </label>
        <input type="range" id="granularitySlider" min="0" max="6" value="0" step="1" class="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer accent-brand-500" />
        <div class="flex justify-between text-xs text-slate-400 mt-1">
          <span>30 min</span>
          <span>1 hr</span>
          <span>3 hr</span>
          <span>6 hr</span>
          <span>12 hr</span>
          <span>1 day</span>
          <span>7 days</span>
        </div>
      </div>
      <p class="mt-2 text-xs text-slate-400">Filter data by date range and adjust data granularity (aggregation level).</p>
    </section>

    <section class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
      <div class="flex items-center gap-3 mb-3">
        <h2 class="text-lg font-medium" id="chartTitle">Item Plays Over Time</h2>
        <span id="chartSubtitle" class="text-xs text-slate-400"></span>
      </div>
      <div class="h-[420px]">
        <canvas id="chart"></canvas>
      </div>
      <p id="emptyState" class="hidden mt-3 text-sm text-slate-400">No data found for this selection.</p>
    </section>

    <section id="rankingsSection" class="mt-4 bg-slate-900/60 border border-white/10 rounded-lg p-4 hidden">
      <h3 class="text-md font-medium mb-3">Rankings</h3>
      <div id="rankingsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
      </div>
    </section>

    <footer class="mt-8 text-xs text-slate-500">
      Data driven by GitHub Action exports. Files are read directly from this repository; no build required.
    </footer>
  </main>

  <script>
    const els = {
      configSelect: document.getElementById('configSelect'),
      dataTypeSelect: document.getElementById('dataTypeSelect'),
      characterSelect: document.getElementById('characterSelect'),
      viewMode: document.getElementById('viewMode'),
      singleCharacterSection: document.getElementById('singleCharacterSection'),
      dateRangeSection: document.getElementById('dateRangeSection'),
      startDate: document.getElementById('startDate'),
      endDate: document.getElementById('endDate'),
      resetDateRange: document.getElementById('resetDateRange'),
      granularitySlider: document.getElementById('granularitySlider'),
      granularityLabel: document.getElementById('granularityLabel'),
      chartCanvas: document.getElementById('chart'),
      chartTitle: document.getElementById('chartTitle'),
      chartSubtitle: document.getElementById('chartSubtitle'),
      emptyState: document.getElementById('emptyState'),
      configMeta: document.getElementById('configMeta'),
      configIcon: document.getElementById('configIcon'),
      characterHint: document.getElementById('characterHint'),
      statsPanel: document.getElementById('statsPanel'),
      statTotalChars: document.getElementById('statTotalChars'),
      statTotalPlays: document.getElementById('statTotalPlays'),
      statMostPopular: document.getElementById('statMostPopular'),
      statMostPopularValue: document.getElementById('statMostPopularValue'),
      statFastestGrowing: document.getElementById('statFastestGrowing'),
      statFastestGrowingValue: document.getElementById('statFastestGrowingValue'),
      statAvgPlays: document.getElementById('statAvgPlays'),
      comparisonSection: document.getElementById('comparisonSection'),
      comparisonSelect: document.getElementById('comparisonSelect'),
      topNSection: document.getElementById('topNSection'),
      topNSelect: document.getElementById('topNSelect'),
      rankingsSection: document.getElementById('rankingsSection'),
      rankingsList: document.getElementById('rankingsList'),
    };

    let chart;
    let autoIndex;
    let currentSeries = {};
    let currentCfg = null;
    let characterConfig = null; // Store character configuration
    let extractedColors = {}; // Cache for extracted colors from images

    async function loadCharacterConfig() {
      try {
        const res = await fetch('character-config.json');
        if (!res.ok) throw new Error('Failed to load character-config.json');
        characterConfig = await res.json();
      } catch (e) {
        console.warn('Character config not available:', e);
        characterConfig = { nameMapping: {}, colorMapping: {} };
      }
    }

    // Extract dominant color from an image
    function extractDominantColor(imagePath, characterName) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        
        img.onload = function() {
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Calculate average color, skipping very dark and very light pixels
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let i = 0; i < data.length; i += 4) {
              const red = data[i];
              const green = data[i + 1];
              const blue = data[i + 2];
              const alpha = data[i + 3];
              
              // Skip transparent pixels
              if (alpha < 128) continue;
              
              // Skip very dark pixels (likely shadows/outlines)
              const brightness = (red + green + blue) / 3;
              if (brightness < 40) continue;
              
              // Skip very light pixels (likely highlights)
              if (brightness > 240) continue;
              
              r += red;
              g += green;
              b += blue;
              count++;
            }
            
            if (count > 0) {
              r = Math.round(r / count);
              g = Math.round(g / count);
              b = Math.round(b / count);
              
              // Increase saturation for more vibrant colors
              const hsl = rgbToHsl(r, g, b);
              hsl[1] = Math.min(1, hsl[1] * 1.5); // Increase saturation by 50%
              hsl[2] = Math.max(0.4, Math.min(0.6, hsl[2])); // Normalize lightness
              
              const rgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
              const color = `#${rgb[0].toString(16).padStart(2, '0')}${rgb[1].toString(16).padStart(2, '0')}${rgb[2].toString(16).padStart(2, '0')}`;
              
              extractedColors[characterName.toLowerCase()] = color;
              resolve(color);
            } else {
              resolve(null);
            }
          } catch (e) {
            console.warn(`Failed to extract color from ${imagePath}:`, e);
            resolve(null);
          }
        };
        
        img.onerror = function() {
          resolve(null);
        };
        
        img.src = imagePath;
      });
    }

    // RGB to HSL conversion
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }

      return [h, s, l];
    }

    // HSL to RGB conversion
    function hslToRgb(h, s, l) {
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    async function loadAutoIndex() {
      const res = await fetch('auto-index.json');
      if (!res.ok) throw new Error('Failed to load auto-index.json');
      autoIndex = await res.json();
      populateConfigSelect(autoIndex.configs || []);
      // Choose default: first config with non-empty character_totals-deltas series
      const findDefault = async () => {
        for (const cfg of autoIndex.configs || []) {
          const path = cfg.paths?.character_totals_deltas;
          if (!path) continue;
          try {
            const r = await fetch(path);
            if (!r.ok) continue;
            const data = await r.json();
            if (data && data.series && Object.keys(data.series).length > 0) return cfg.slug;
          } catch {}
        }
        return autoIndex.configs?.[0]?.slug;
      };
      const defSlug = await findDefault();
      if (defSlug) {
        els.configSelect.value = defSlug;
        handleConfigChange();
      }
    }

    function populateConfigSelect(configs) {
      els.configSelect.innerHTML = '';
      for (const cfg of configs) {
        const opt = document.createElement('option');
        opt.value = cfg.slug;
        opt.textContent = (cfg.config?.split('/')?.slice(-2)?.join(' / ')) || cfg.slug;
        els.configSelect.appendChild(opt);
      }
    }

    async function handleConfigChange() {
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      els.configIcon.src = cfg.icon || '';
      els.configIcon.classList.toggle('hidden', !cfg.icon);
      els.configMeta.textContent = cfg.config || '';
      
      // Load data based on selected type
      await loadDataType();
    }
    
    async function loadDataType() {
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      
      const dataType = els.dataTypeSelect.value;
      const path = cfg.paths?.[dataType];
      let data;
      try {
        const res = await fetch(path);
        data = await res.json();
      } catch (e) {
        data = { series: {} };
      }
      const series = data?.series || {};
      populateCharacterSelect(series, cfg);
    }

    function populateCharacterSelect(series, cfg) {
      const names = Object.keys(series).sort();
      els.characterSelect.innerHTML = '';
      currentSeries = series;
      currentCfg = cfg;
      
      // Set date range based on data
      updateDateRangeLimits(series);
      
      // Also populate comparison select
      populateComparisonSelect(series);
      
      if (names.length === 0) {
        const opt = document.createElement('option');
        opt.textContent = 'No characters in this config yet';
        els.characterSelect.appendChild(opt);
        els.characterSelect.disabled = true;
        els.characterHint.textContent = 'No data available for this config yet.';
        updateChart([], cfg);
        return;
      }
      for (const name of names) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        els.characterSelect.appendChild(opt);
      }
      els.characterSelect.disabled = false;
      els.characterHint.textContent = 'Showing cumulative plays (c) over time.';
      els.characterSelect.value = names[0];
      handleCharacterChange(series, cfg);
    }

    function updateDateRangeLimits(series) {
      let minDate = null;
      let maxDate = null;
      
      for (const points of Object.values(series)) {
        for (const point of points) {
          const date = new Date(point.t);
          if (!minDate || date < minDate) minDate = date;
          if (!maxDate || date > maxDate) maxDate = date;
        }
      }
      
      if (minDate && maxDate) {
        els.startDate.min = minDate.toISOString().split('T')[0];
        els.startDate.max = maxDate.toISOString().split('T')[0];
        els.endDate.min = minDate.toISOString().split('T')[0];
        els.endDate.max = maxDate.toISOString().split('T')[0];
      }
    }

    // Granularity settings: value -> [minutes, label]
    const granularitySettings = {
      0: [30, '30 min'],
      1: [60, '1 hr'],
      2: [180, '3 hr'],
      3: [360, '6 hr'],
      4: [720, '12 hr'],
      5: [1440, '1 day'],
      6: [10080, '7 days']
    };

    function aggregateDataByGranularity(points) {
      const granularityValue = parseInt(els.granularitySlider.value);
      if (granularityValue === 0) return points; // No aggregation for 30 min (original)
      
      const [intervalMinutes] = granularitySettings[granularityValue];
      const intervalMs = intervalMinutes * 60 * 1000;
      
      if (points.length === 0) return points;
      
      // Sort points by time
      const sortedPoints = points.slice().sort((a, b) => new Date(a.t) - new Date(b.t));
      
      const aggregated = [];
      let currentBucket = null;
      let bucketStartTime = null;
      let deltaSum = 0;
      let lastCumulative = null;
      
      for (const point of sortedPoints) {
        const pointTime = new Date(point.t).getTime();
        
        // Determine bucket start time (floor to interval)
        const bucketStart = Math.floor(pointTime / intervalMs) * intervalMs;
        
        if (bucketStartTime === null || bucketStart !== bucketStartTime) {
          // Save previous bucket if exists
          if (currentBucket !== null) {
            aggregated.push(currentBucket);
          }
          
          // Start new bucket
          bucketStartTime = bucketStart;
          currentBucket = {
            t: new Date(bucketStartTime).toISOString(),
            d: point.d ?? 0,
            ...(point.c !== undefined && { c: point.c })
          };
          deltaSum = point.d ?? 0;
          lastCumulative = point.c;
        } else {
          // Add to current bucket
          deltaSum += (point.d ?? 0);
          currentBucket.d = deltaSum;
          if (point.c !== undefined) {
            lastCumulative = point.c;
            currentBucket.c = point.c;
          }
        }
      }
      
      // Save last bucket
      if (currentBucket !== null) {
        aggregated.push(currentBucket);
      }
      
      return aggregated;
    }

    function filterDataByDateRange(points) {
      if (!els.startDate.value && !els.endDate.value) return aggregateDataByGranularity(points);
      
      const startTime = els.startDate.value ? new Date(els.startDate.value).getTime() : -Infinity;
      const endTime = els.endDate.value ? new Date(els.endDate.value + 'T23:59:59').getTime() : Infinity;
      
      const filtered = points.filter(p => {
        const t = new Date(p.t).getTime();
        return t >= startTime && t <= endTime;
      });
      
      return aggregateDataByGranularity(filtered);
    }

    function handleCharacterChange(series, cfg) {
      const name = els.characterSelect.value;
      const allPoints = (series[name] || []).slice().sort((a,b) => new Date(a.t) - new Date(b.t));
      const points = filterDataByDateRange(allPoints);
      const data = points.map(p => ({ x: new Date(p.t), y: Number(p.c ?? p.d ?? 0) }));
      updateChart(data, cfg, name);
    }

    async function updateChart(data, cfg, name) {
      const viewMode = els.viewMode.value;
      
      if (viewMode === 'single') {
        updateSingleCharacterChart(data, cfg, name);
      } else if (viewMode === 'all') {
        await updateAllCharactersChart(currentSeries, cfg);
      } else if (viewMode === 'allLines') {
        await updateAllCharactersLineChart(currentSeries, cfg);
      } else if (viewMode === 'slope') {
        updateSlopeChart(currentSeries, cfg);
      } else if (viewMode === 'pie') {
        await updatePieChart(currentSeries, cfg);
      } else if (viewMode === 'comparison') {
        await updateComparisonChart(currentSeries, cfg);
      }
      
      // Update stats panel for all views
      updateStatsPanel(currentSeries, cfg);
      
      // Update rankings for comparison views
      updateRankings(currentSeries, cfg, viewMode);
    }

    function updateSingleCharacterChart(data, cfg, name) {
      els.emptyState.classList.toggle('hidden', data.length > 0);
      els.chartTitle.textContent = 'Item Plays Over Time';
      els.chartSubtitle.textContent = name ? `${name} — ${cfg?.slug || ''}` : (cfg?.slug || '');

      const gradient = (() => {
        const ctx = els.chartCanvas.getContext('2d');
        const g = ctx.createLinearGradient(0, 0, 0, 400);
        g.addColorStop(0, 'rgba(74,118,255,0.35)');
        g.addColorStop(1, 'rgba(74,118,255,0.03)');
        return g;
      })();

      const ds = {
        label: 'Plays (cumulative)',
        data,
        fill: true,
        borderColor: '#4a76ff',
        backgroundColor: gradient,
        pointRadius: 2,
        tension: 0.25,
      };

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: { datasets: [ds] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'PPpp' },
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            }
          },
          plugins: {
            legend: { labels: { color: 'rgba(255,255,255,0.8)' } },
            tooltip: {
              callbacks: {
                label: (ctx) => ` ${ctx.dataset.label}: ${ctx.parsed.y}`
              }
            }
          }
        }
      });
    }

    async function updateAllCharactersChart(series, cfg) {
      els.chartTitle.textContent = 'All Items Popularity';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // Get the latest cumulative value for each character
      const characterData = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        characterData.push({ name, value: latestValue });
      }
      
      // Sort by value descending
      characterData.sort((a, b) => b.value - a.value);
      
      els.emptyState.classList.toggle('hidden', characterData.length > 0);
      
      const labels = characterData.map(d => d.name);
      const values = characterData.map(d => d.value);
      
      // Use character-specific colors with fallback to gradient
      const colors = await getColorPalette(labels, cfg);

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Total Plays',
            data: values,
            backgroundColor: colors,
            borderColor: colors.map(c => c + 'cc'), // Add slight transparency to border
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { 
                color: 'rgba(255,255,255,0.7)',
                font: { size: 10 }
              }
            }
          },
          plugins: {
            legend: { 
              display: false
            },
            tooltip: {
              callbacks: {
                label: (ctx) => ` Total Plays: ${ctx.parsed.x.toLocaleString()}`
              }
            }
          }
        }
      });
    }

    async function updateAllCharactersLineChart(series, cfg) {
      els.chartTitle.textContent = 'All Items - Plays in Period Over Time';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // First, get top N characters by total plays
      const topN = parseInt(els.topNSelect.value) || 0;
      let charactersByPopularity = [];
      
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length < 1) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        charactersByPopularity.push({ name, value: latestValue });
      }
      
      charactersByPopularity.sort((a, b) => b.value - a.value);
      const topCharacters = topN > 0 ? charactersByPopularity.slice(0, topN).map(c => c.name) : charactersByPopularity.map(c => c.name);
      
      // Now build the line chart with only top characters
      const allTimestamps = new Set();
      const filteredSeries = {};
      
      for (const [name, allPoints] of Object.entries(series)) {
        if (!topCharacters.includes(name)) continue;
        const points = filterDataByDateRange(allPoints);
        if (points.length < 1) continue;
        filteredSeries[name] = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        filteredSeries[name].forEach(p => allTimestamps.add(p.t));
      }
      
      // Convert to sorted array
      const timestamps = Array.from(allTimestamps).sort((a, b) => new Date(a) - new Date(b));
      
      if (timestamps.length < 2) {
        els.emptyState.classList.toggle('hidden', false);
        if (chart) chart.destroy();
        return;
      }
      
      const datasets = [];
      const colors = await getColorPalette(topCharacters, cfg);
      
      let colorIndex = 0;
      for (const [name, points] of Object.entries(filteredSeries)) {
        // Create a map of timestamp -> point data
        const pointMap = new Map();
        points.forEach(p => pointMap.set(p.t, p));
        
        // Fill in all timestamps, carrying forward cumulative values
        const normalizedPoints = [];
        let lastCumulative = 0;
        
        for (const timestamp of timestamps) {
          if (pointMap.has(timestamp)) {
            const point = pointMap.get(timestamp);
            lastCumulative = Number(point.c ?? lastCumulative);
            normalizedPoints.push({ t: timestamp, c: lastCumulative, d: Number(point.d ?? 0) });
          } else {
            // Missing data point - use last cumulative value (delta = 0)
            normalizedPoints.push({ t: timestamp, c: lastCumulative, d: 0 });
          }
        }
        
        // Use delta (plays in that period) instead of rate
        const deltaData = [];
        for (let i = 1; i < normalizedPoints.length; i++) {
          const prevPoint = normalizedPoints[i - 1];
          const currPoint = normalizedPoints[i];
          
          const valueDiff = currPoint.c - prevPoint.c;
          
          deltaData.push({
            x: new Date(currPoint.t),
            y: valueDiff
          });
        }
        
        if (deltaData.length > 0) {
          const color = colors[colorIndex % colors.length];
          datasets.push({
            label: name,
            data: deltaData,
            borderColor: color,
            backgroundColor: color + '20',
            borderWidth: 2,
            pointRadius: 1,
            pointHoverRadius: 4,
            tension: 0.3,
            fill: false
          });
          colorIndex++;
        }
      }
      
      els.emptyState.classList.toggle('hidden', datasets.length > 0);
      
      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'PPpp' },
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' },
              title: {
                display: true,
                text: 'Plays in Period',
                color: 'rgba(255,255,255,0.8)'
              }
            }
          },
          plugins: {
            legend: { 
              labels: { color: 'rgba(255,255,255,0.8)', font: { size: 10 } },
              position: 'top',
              maxHeight: 100
            },
            tooltip: {
              callbacks: {
                beforeBody: function(tooltipItems) {
                  // Sort tooltip items by value (descending)
                  tooltipItems.sort((a, b) => b.parsed.y - a.parsed.y);
                },
                label: (ctx) => ` ${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} plays`
              }
            }
          },
          onClick: (event, activeElements) => {
            if (activeElements.length > 0) {
              const dataIndex = activeElements[0].index;
              const timestamp = datasets[0].data[dataIndex].x;
              showLeaderboardAtTime(series, cfg, timestamp, 'delta');
            }
          }
        }
      });
    }

    function updateSlopeChart(series, cfg) {
      els.chartTitle.textContent = 'Item Popularity Trends (Slope)';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // Calculate slope (growth rate) for each character
      const characterSlopes = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length < 2) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        
        // Calculate simple linear regression slope
        const n = sortedPoints.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        
        sortedPoints.forEach((point, idx) => {
          const x = idx;
          const y = Number(point.c ?? 0);
          sumX += x;
          sumY += y;
          sumXY += x * y;
          sumX2 += x * x;
        });
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const latestValue = Number(sortedPoints[sortedPoints.length - 1].c ?? 0);
        
        characterSlopes.push({ name, slope, latestValue });
      }
      
      // Sort by slope descending
      characterSlopes.sort((a, b) => b.slope - a.slope);
      
      // Apply top N filter
      const topN = parseInt(els.topNSelect.value) || 0;
      const filteredSlopes = topN > 0 ? characterSlopes.slice(0, topN) : characterSlopes;
      
      els.emptyState.classList.toggle('hidden', filteredSlopes.length > 0);
      
      const labels = filteredSlopes.map(d => d.name);
      const slopes = filteredSlopes.map(d => d.slope);
      
      // Color based on slope (positive = green, negative = red)
      const colors = slopes.map(slope => {
        if (slope > 0) {
          const intensity = Math.min(slope / Math.max(...slopes), 1);
          return `rgba(74, 222, 128, ${0.4 + intensity * 0.6})`;
        } else {
          const intensity = Math.min(Math.abs(slope) / Math.max(...slopes.map(Math.abs)), 1);
          return `rgba(248, 113, 113, ${0.4 + intensity * 0.6})`;
        }
      });

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Growth Rate (plays/datapoint)',
            data: slopes,
            backgroundColor: colors,
            borderColor: colors.map(c => c.replace(/[\d.]+\)$/, '1)')),
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { 
                color: 'rgba(255,255,255,0.7)',
                font: { size: 10 }
              }
            }
          },
          plugins: {
            legend: { 
              display: false
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const idx = ctx.dataIndex;
                  const charData = filteredSlopes[idx];
                  return [
                    ` Growth Rate: ${ctx.parsed.x.toFixed(2)} plays/point`,
                    ` Current Total: ${charData.latestValue.toLocaleString()} plays`
                  ];
                }
              }
            }
          }
        }
      });
    }

    async function updatePieChart(series, cfg) {
      els.chartTitle.textContent = 'Item Market Share';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // Get the latest cumulative value for each character
      const characterData = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        if (latestValue > 0) {
          characterData.push({ name, value: latestValue });
        }
      }
      
      // Sort by value descending
      characterData.sort((a, b) => b.value - a.value);
      
      // Apply top N filter
      const topN = parseInt(els.topNSelect.value) || 0;
      const filteredData = topN > 0 ? characterData.slice(0, topN) : characterData;
      
      els.emptyState.classList.toggle('hidden', filteredData.length > 0);
      
      const labels = filteredData.map(d => d.name);
      const values = filteredData.map(d => d.value);
      
      // Use character-specific colors
      const colors = await getColorPalette(labels, cfg);

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'doughnut',
        data: {
          labels,
          datasets: [{
            label: 'Total Plays',
            data: values,
            backgroundColor: colors,
            borderColor: '#1e293b',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { 
              labels: { color: 'rgba(255,255,255,0.8)', font: { size: 10 } },
              position: 'right',
              maxHeight: 400
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const total = values.reduce((a, b) => a + b, 0);
                  const percentage = ((ctx.parsed / total) * 100).toFixed(1);
                  return ` ${ctx.label}: ${ctx.parsed.toLocaleString()} plays (${percentage}%)`;
                }
              }
            }
          }
        }
      });
    }

    async function updateComparisonChart(series, cfg) {
      els.chartTitle.textContent = 'Item Comparison';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      const selectedChars = Array.from(els.comparisonSelect.selectedOptions).map(opt => opt.value);
      
      if (selectedChars.length < 2) {
        els.emptyState.classList.toggle('hidden', false);
        if (chart) chart.destroy();
        return;
      }
      
      const datasets = [];
      const colors = await getColorPalette(selectedChars, cfg);
      
      selectedChars.forEach((name, idx) => {
        const allPoints = series[name] || [];
        const points = filterDataByDateRange(allPoints).slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        const data = points.map(p => ({ x: new Date(p.t), y: Number(p.c ?? p.d ?? 0) }));
        
        const color = colors[idx];
        datasets.push({
          label: name,
          data,
          borderColor: color,
          backgroundColor: color + '20',
          borderWidth: 3,
          pointRadius: 3,
          pointHoverRadius: 5,
          tension: 0.3,
          fill: false
        });
      });
      
      els.emptyState.classList.toggle('hidden', datasets.length > 0);
      
      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'PPpp' },
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' },
              title: {
                display: true,
                text: 'Cumulative Plays',
                color: 'rgba(255,255,255,0.8)'
              }
            }
          },
          plugins: {
            legend: { 
              labels: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } },
              position: 'top'
            },
            tooltip: {
              callbacks: {
                beforeBody: function(tooltipItems) {
                  // Sort tooltip items by value (descending)
                  tooltipItems.sort((a, b) => b.parsed.y - a.parsed.y);
                },
                label: (ctx) => ` ${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} plays`
              }
            }
          },
          onClick: (event, activeElements) => {
            if (activeElements.length > 0) {
              const dataIndex = activeElements[0].index;
              const timestamp = datasets[0].data[dataIndex].x;
              showLeaderboardAtTime(series, cfg, timestamp, 'cumulative');
            }
          }
        }
      });
    }

    function updateStatsPanel(series, cfg) {
      if (!series || Object.keys(series).length === 0) {
        els.statsPanel.classList.add('hidden');
        return;
      }
      
      els.statsPanel.classList.remove('hidden');
      
      // Calculate stats
      const characterData = [];
      const characterSlopes = [];
      
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        characterData.push({ name, value: latestValue });
        
        // Calculate slope for growth rate
        if (points.length >= 2) {
          const sortedForSlope = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
          const n = sortedForSlope.length;
          let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
          
          sortedForSlope.forEach((point, idx) => {
            const x = idx;
            const y = Number(point.c ?? 0);
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
          });
          
          const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
          characterSlopes.push({ name, slope, latestValue });
        }
      }
      
      // Total characters
      els.statTotalChars.textContent = characterData.length;
      
      // Total plays
      const totalPlays = characterData.reduce((sum, c) => sum + c.value, 0);
      els.statTotalPlays.textContent = totalPlays.toLocaleString();
      
      // Most popular
      if (characterData.length > 0) {
        characterData.sort((a, b) => b.value - a.value);
        els.statMostPopular.textContent = characterData[0].name;
        els.statMostPopularValue.textContent = characterData[0].value.toLocaleString() + ' plays';
      }
      
      // Fastest growing
      if (characterSlopes.length > 0) {
        characterSlopes.sort((a, b) => b.slope - a.slope);
        els.statFastestGrowing.textContent = characterSlopes[0].name;
        els.statFastestGrowingValue.textContent = '+' + characterSlopes[0].slope.toFixed(1) + ' plays/point';
      }
      
      // Average plays per character
      const avgPlays = characterData.length > 0 ? Math.round(totalPlays / characterData.length) : 0;
      els.statAvgPlays.textContent = avgPlays.toLocaleString();
    }

    function populateComparisonSelect(series) {
      els.comparisonSelect.innerHTML = '';
      const names = Object.keys(series).sort();
      for (const name of names) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        els.comparisonSelect.appendChild(opt);
      }
    }

    function getCharacterImagePath(characterName, cfg) {
      // Return the character image path if available
      if (!cfg || !cfg.icons_dir) return null;
      if (!characterConfig) return null;
      
      // Use the name mapping from the JSON config
      const lowerName = characterName.toLowerCase();
      const normalizedName = characterConfig.nameMapping[lowerName] || characterName.toLowerCase().replace(/\s+/g, '');
      return `${cfg.icons_dir}/${normalizedName}.png`;
    }

    // Get character-specific color - uses JSON override first, then extracted color, then null
    async function getCharacterColor(characterName, cfg) {
      if (!characterConfig || !characterConfig.colorMapping) {
        console.warn('Character config not loaded yet for color lookup');
        return null;
      }
      
      const lowerName = characterName.toLowerCase();
      
      // First check for manual override in JSON
      if (characterConfig.colorMapping[lowerName]) {
        return characterConfig.colorMapping[lowerName];
      }
      
      // Check if we already extracted this color
      if (extractedColors[lowerName]) {
        return extractedColors[lowerName];
      }
      
      // Try to extract color from character image
      const imagePath = getCharacterImagePath(characterName, cfg);
      if (imagePath) {
        const extractedColor = await extractDominantColor(imagePath, characterName);
        if (extractedColor) {
          return extractedColor;
        }
      }
      
      return null;
    }

    // Get color palette for charts, using character colors when available
    async function getColorPalette(characterNames, cfg) {
      if (!characterNames || characterNames.length === 0) {
        // Default color palette
        return [
          '#4a76ff', '#ff6b6b', '#51cf66', '#ffd93d', '#a78bfa', 
          '#fb7185', '#60a5fa', '#34d399', '#fbbf24', '#c084fc',
          '#f472b6', '#38bdf8', '#6ee7b7', '#fdba74', '#e879f9',
          '#fb923c', '#67e8f9', '#86efac', '#fca5a5', '#d8b4fe'
        ];
      }
      
      // Get colors for all characters (with extraction)
      const colorPromises = characterNames.map(name => getCharacterColor(name, cfg));
      const colors = await Promise.all(colorPromises);
      
      // Map results with fallback to default palette
      const defaultPalette = [
        '#4a76ff', '#ff6b6b', '#51cf66', '#ffd93d', '#a78bfa', 
        '#fb7185', '#60a5fa', '#34d399', '#fbbf24', '#c084fc',
        '#f472b6', '#38bdf8', '#6ee7b7', '#fdba74', '#e879f9',
        '#fb923c', '#67e8f9', '#86efac', '#fca5a5', '#d8b4fe'
      ];
      
      return colors.map((color, idx) => {
        if (color) return color;
        return defaultPalette[idx % defaultPalette.length];
      });
    }

    function updateRankings(series, cfg, viewMode) {
      // Show rankings for comparison views
      const shouldShowRankings = ['all', 'allLines', 'slope', 'pie'].includes(viewMode);
      els.rankingsSection.classList.toggle('hidden', !shouldShowRankings);
      
      if (!shouldShowRankings) return;
      
      // Calculate rankings by total plays
      const rankings = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        
        // Calculate growth rate
        let growthRate = 0;
        if (points.length >= 2) {
          const sortedForSlope = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
          const n = sortedForSlope.length;
          let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
          
          sortedForSlope.forEach((point, idx) => {
            const x = idx;
            const y = Number(point.c ?? 0);
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
          });
          
          growthRate = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        }
        
        rankings.push({ name, plays: latestValue, growthRate });
      }
      
      // Sort by plays descending
      rankings.sort((a, b) => b.plays - a.plays);
      
      // Apply top N filter if available
      const topN = parseInt(els.topNSelect.value) || 0;
      const displayRankings = topN > 0 ? rankings.slice(0, topN) : rankings.slice(0, 20);
      
      // Update rankings display
      els.rankingsList.innerHTML = '';
      displayRankings.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'flex items-center gap-2 p-2 bg-slate-800/50 rounded text-xs';
        
        const rankBadge = document.createElement('span');
        rankBadge.className = 'flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center font-bold text-xs ' +
          (idx === 0 ? 'bg-yellow-500 text-slate-900' : 
           idx === 1 ? 'bg-gray-400 text-slate-900' :
           idx === 2 ? 'bg-amber-600 text-slate-900' :
           'bg-slate-700 text-slate-300');
        rankBadge.textContent = idx + 1;
        
        // Add character image if available
        const imagePath = getCharacterImagePath(item.name, cfg);
        if (imagePath) {
          const img = document.createElement('img');
          img.src = imagePath;
          img.className = 'w-8 h-8 rounded-full object-cover flex-shrink-0';
          img.alt = item.name;
          img.onerror = function() { this.style.display = 'none'; };
          div.appendChild(rankBadge);
          div.appendChild(img);
        } else {
          div.appendChild(rankBadge);
        }
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'flex-1 truncate';
        nameSpan.textContent = item.name;
        
        const playsSpan = document.createElement('span');
        playsSpan.className = 'text-brand-400 font-mono';
        playsSpan.textContent = item.plays.toLocaleString();
        
        const growthSpan = document.createElement('span');
        growthSpan.className = 'ml-2 ' + (item.growthRate >= 0 ? 'text-green-400' : 'text-red-400');
        growthSpan.textContent = (item.growthRate >= 0 ? '+' : '') + item.growthRate.toFixed(1);
        
        div.appendChild(nameSpan);
        div.appendChild(playsSpan);
        div.appendChild(growthSpan);
        els.rankingsList.appendChild(div);
      });
    }

    function showLeaderboardAtTime(series, cfg, timestamp, mode = 'cumulative') {
      // Calculate values at the specific timestamp
      const leaderboard = [];
      const targetTime = new Date(timestamp).getTime();
      
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        
        // Find the value at or before the clicked timestamp
        const sortedPoints = points.slice().sort((a, b) => new Date(a.t) - new Date(b.t));
        let value = 0;
        
        if (mode === 'rate') {
          // For rate mode, calculate the rate at that point
          for (let i = 1; i < sortedPoints.length; i++) {
            const currTime = new Date(sortedPoints[i].t).getTime();
            if (currTime <= targetTime) {
              const prevPoint = sortedPoints[i - 1];
              const currPoint = sortedPoints[i];
              const timeDiff = (new Date(currPoint.t) - new Date(prevPoint.t)) / (1000 * 60 * 60); // hours
              const valueDiff = (Number(currPoint.c ?? 0)) - (Number(prevPoint.c ?? 0));
              value = timeDiff > 0 ? valueDiff / timeDiff : 0;
            } else {
              break;
            }
          }
        } else if (mode === 'delta') {
          // For delta mode, calculate the plays in that period
          for (let i = 1; i < sortedPoints.length; i++) {
            const currTime = new Date(sortedPoints[i].t).getTime();
            if (currTime <= targetTime) {
              const prevPoint = sortedPoints[i - 1];
              const currPoint = sortedPoints[i];
              value = (Number(currPoint.c ?? 0)) - (Number(prevPoint.c ?? 0));
            } else {
              break;
            }
          }
        } else {
          // For cumulative mode, find the last value at or before timestamp
          for (const point of sortedPoints) {
            if (new Date(point.t).getTime() <= targetTime) {
              value = Number(point.c ?? point.d ?? 0);
            } else {
              break;
            }
          }
        }
        
        if (value > 0 || mode === 'cumulative') {
          leaderboard.push({ name, value });
        }
      }
      
      // Sort by value descending
      leaderboard.sort((a, b) => b.value - a.value);
      
      // Update rankings section
      els.rankingsSection.classList.remove('hidden');
      const dateStr = new Date(timestamp).toLocaleString();
      const header = els.rankingsSection.querySelector('h3');
      header.textContent = `Leaderboard at ${dateStr}`;
      
      // Apply top N filter if available
      const topN = parseInt(els.topNSelect.value) || 0;
      const displayRankings = topN > 0 ? leaderboard.slice(0, topN) : leaderboard.slice(0, 20);
      
      // Update rankings display
      els.rankingsList.innerHTML = '';
      displayRankings.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'flex items-center gap-2 p-2 bg-slate-800/50 rounded text-xs';
        
        const rankBadge = document.createElement('span');
        rankBadge.className = 'flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center font-bold text-xs ' +
          (idx === 0 ? 'bg-yellow-500 text-slate-900' : 
           idx === 1 ? 'bg-gray-400 text-slate-900' :
           idx === 2 ? 'bg-amber-600 text-slate-900' :
           'bg-slate-700 text-slate-300');
        rankBadge.textContent = idx + 1;
        
        // Add character image if available
        const imagePath = getCharacterImagePath(item.name, cfg);
        if (imagePath) {
          const img = document.createElement('img');
          img.src = imagePath;
          img.className = 'w-8 h-8 rounded-full object-cover flex-shrink-0';
          img.alt = item.name;
          img.onerror = function() { this.style.display = 'none'; };
          div.appendChild(rankBadge);
          div.appendChild(img);
        } else {
          div.appendChild(rankBadge);
        }
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'flex-1 truncate';
        nameSpan.textContent = item.name;
        
        const valueSpan = document.createElement('span');
        valueSpan.className = 'text-brand-400 font-mono';
        if (mode === 'rate') {
          valueSpan.textContent = item.value.toFixed(2) + ' /hr';
        } else if (mode === 'delta') {
          valueSpan.textContent = item.value.toLocaleString() + ' plays';
        } else {
          valueSpan.textContent = item.value.toLocaleString();
        }
        
        div.appendChild(nameSpan);
        div.appendChild(valueSpan);
        els.rankingsList.appendChild(div);
      });
    }

    // Events
    els.configSelect.addEventListener('change', handleConfigChange);
    els.dataTypeSelect.addEventListener('change', loadDataType);
    els.characterSelect.addEventListener('change', () => {
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      fetch(cfg.paths.character_totals_deltas)
        .then(r => r.json())
        .then(data => handleCharacterChange(data.series || {}, cfg));
    });
    
    els.viewMode.addEventListener('change', () => {
      const viewMode = els.viewMode.value;
      els.singleCharacterSection.style.display = viewMode === 'single' ? 'block' : 'none';
      els.comparisonSection.style.display = viewMode === 'comparison' ? 'block' : 'none';
      els.topNSection.style.display = (viewMode === 'allLines' || viewMode === 'slope' || viewMode === 'pie') ? 'block' : 'none';
      
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      
      if (viewMode === 'single') {
        // Reload current character
        const name = els.characterSelect.value;
        const allPoints = (currentSeries[name] || []).slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        const points = filterDataByDateRange(allPoints);
        const data = points.map(p => ({ x: new Date(p.t), y: Number(p.c ?? p.d ?? 0) }));
        updateChart(data, cfg, name);
      } else {
        // Show all characters or other views
        updateChart([], cfg);
      }
    });
    
    els.comparisonSelect.addEventListener('change', () => {
      if (currentCfg && els.viewMode.value === 'comparison') {
        updateChart([], currentCfg);
      }
    });
    
    els.topNSelect.addEventListener('change', () => {
      if (currentCfg) {
        updateChart([], currentCfg);
      }
    });
    
    els.startDate.addEventListener('change', () => {
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });
    
    els.endDate.addEventListener('change', () => {
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });
    
    els.resetDateRange.addEventListener('click', () => {
      els.startDate.value = '';
      els.endDate.value = '';
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });

    els.granularitySlider.addEventListener('input', () => {
      const value = parseInt(els.granularitySlider.value);
      const [_, label] = granularitySettings[value];
      els.granularityLabel.textContent = label;
    });

    els.granularitySlider.addEventListener('change', () => {
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });

    // Init
    Promise.all([
      loadCharacterConfig(),
      loadAutoIndex()
    ]).catch(err => {
      console.error(err);
      els.configSelect.innerHTML = '<option>Failed to load configuration</option>';
    });
  </script>
</body>
</html>
