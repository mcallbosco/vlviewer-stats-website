<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VLViewer Stats Website</title>
  <meta name="description" content="Track character plays over time across configs" />
  <link rel="icon" href="auto/deadlock-deadlockaugust22025/icon.png" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind config to get a dark style similar vibe
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50: '#f2f6ff',
              100: '#dde7ff',
              200: '#b6c8ff',
              300: '#8fa8ff',
              400: '#6d8fff',
              500: '#4a76ff',
              600: '#335de6',
              700: '#2949b4',
              800: '#213a8c',
              900: '#1a2e6e'
            }
          }
        }
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-800 text-slate-100">
  <header class="border-b border-white/10 bg-slate-900/50 backdrop-blur sticky top-0 z-10">
    <div class="max-w-6xl mx-auto px-4 py-4 flex items-center gap-3">
      <img id="configIcon" src="auto/deadlock-deadlockaugust22025/icon.png" alt="Config Icon" class="h-8 w-8 rounded" />
      <h1 class="text-xl font-semibold tracking-wide">VLViewer Stats</h1>
      <span class="ml-auto text-xs text-slate-400">Static prototype</span>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6">
    <section class="mb-4 grid grid-cols-1 md:grid-cols-4 gap-3">
      <div class="col-span-2 bg-slate-900/60 border border-white/10 rounded-lg p-4">
        <label for="configSelect" class="block text-sm mb-1 text-slate-300">Select Config</label>
        <select id="configSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500"></select>
        <p id="configMeta" class="mt-2 text-xs text-slate-400"></p>
      </div>
      <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
        <label for="dataTypeSelect" class="block text-sm mb-1 text-slate-300">Data Type</label>
        <select id="dataTypeSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
          <option value="character_totals_deltas">Characters</option>
          <option value="voicelines_deltas">Voicelines</option>
          <option value="conversations_deltas">Conversations</option>
        </select>
        <p class="mt-2 text-xs text-slate-400">Select type of data to view.</p>
      </div>
      <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
        <label for="viewMode" class="block text-sm mb-1 text-slate-300">View Mode</label>
        <select id="viewMode" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
          <option value="single">Single Item</option>
          <option value="all">All Items</option>
          <option value="allLines">All Items (Lines)</option>
          <option value="slope">Slope Chart (Trends)</option>
          <option value="pie">Market Share (Pie)</option>
          <option value="comparison">Compare Items</option>
        </select>
        <p class="mt-2 text-xs text-slate-400">Choose how to visualize the data.</p>
      </div>
    </section>

    <section id="statsPanel" class="mb-4 hidden">
      <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Total Items</div>
          <div id="statTotalChars" class="text-2xl font-bold text-brand-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Total Plays</div>
          <div id="statTotalPlays" class="text-2xl font-bold text-brand-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Most Popular</div>
          <div id="statMostPopular" class="text-sm font-bold text-green-400 truncate">-</div>
          <div id="statMostPopularValue" class="text-xs text-slate-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Fastest Growing</div>
          <div id="statFastestGrowing" class="text-sm font-bold text-purple-400 truncate">-</div>
          <div id="statFastestGrowingValue" class="text-xs text-slate-400">-</div>
        </div>
        <div class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
          <div class="text-xs text-slate-400 mb-1">Avg per Item</div>
          <div id="statAvgPlays" class="text-2xl font-bold text-brand-400">-</div>
        </div>
      </div>
    </section>

    <section id="comparisonSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4 hidden">
      <label class="block text-sm mb-2 text-slate-300">Select Items to Compare (hold Ctrl/Cmd for multiple)</label>
      <select id="comparisonSelect" multiple size="6" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
      </select>
      <p class="mt-2 text-xs text-slate-400">Select 2-6 items to compare their trends.</p>
    </section>

    <section id="topNSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4 hidden">
      <label for="topNSelect" class="block text-sm mb-1 text-slate-300">Show Top N Items</label>
      <select id="topNSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500">
        <option value="0">All Items</option>
        <option value="5">Top 5</option>
        <option value="10" selected>Top 10</option>
        <option value="15">Top 15</option>
        <option value="20">Top 20</option>
      </select>
      <p class="mt-2 text-xs text-slate-400">Filter to show only the most popular items.</p>
    </section>

    <section id="singleCharacterSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4">
      <label for="characterSelect" class="block text-sm mb-1 text-slate-300">Select Item</label>
      <select id="characterSelect" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500" disabled>
        <option>Loading…</option>
      </select>
      <p id="characterHint" class="mt-2 text-xs text-slate-400">Choose a config to load characters.</p>
    </section>

    <section id="dateRangeSection" class="mb-4 bg-slate-900/60 border border-white/10 rounded-lg p-4">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
        <div>
          <label for="startDate" class="block text-sm mb-1 text-slate-300">Start Date</label>
          <input type="date" id="startDate" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500" />
        </div>
        <div>
          <label for="endDate" class="block text-sm mb-1 text-slate-300">End Date</label>
          <input type="date" id="endDate" class="w-full bg-slate-800 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500" />
        </div>
        <div class="flex items-end">
          <button id="resetDateRange" class="w-full bg-slate-800 hover:bg-slate-700 border border-white/10 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-brand-500 transition-colors">
            Reset Range
          </button>
        </div>
      </div>
      <p class="mt-2 text-xs text-slate-400">Filter data by date range (leave empty for all data).</p>
    </section>

    <section class="bg-slate-900/60 border border-white/10 rounded-lg p-4">
      <div class="flex items-center gap-3 mb-3">
        <h2 class="text-lg font-medium" id="chartTitle">Item Plays Over Time</h2>
        <span id="chartSubtitle" class="text-xs text-slate-400"></span>
      </div>
      <div class="h-[420px]">
        <canvas id="chart"></canvas>
      </div>
      <p id="emptyState" class="hidden mt-3 text-sm text-slate-400">No data found for this selection.</p>
    </section>

    <section id="rankingsSection" class="mt-4 bg-slate-900/60 border border-white/10 rounded-lg p-4 hidden">
      <h3 class="text-md font-medium mb-3">Rankings</h3>
      <div id="rankingsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
      </div>
    </section>

    <footer class="mt-8 text-xs text-slate-500">
      Data driven by GitHub Action exports. Files are read directly from this repository; no build required.
    </footer>
  </main>

  <script>
    const els = {
      configSelect: document.getElementById('configSelect'),
      dataTypeSelect: document.getElementById('dataTypeSelect'),
      characterSelect: document.getElementById('characterSelect'),
      viewMode: document.getElementById('viewMode'),
      singleCharacterSection: document.getElementById('singleCharacterSection'),
      dateRangeSection: document.getElementById('dateRangeSection'),
      startDate: document.getElementById('startDate'),
      endDate: document.getElementById('endDate'),
      resetDateRange: document.getElementById('resetDateRange'),
      chartCanvas: document.getElementById('chart'),
      chartTitle: document.getElementById('chartTitle'),
      chartSubtitle: document.getElementById('chartSubtitle'),
      emptyState: document.getElementById('emptyState'),
      configMeta: document.getElementById('configMeta'),
      configIcon: document.getElementById('configIcon'),
      characterHint: document.getElementById('characterHint'),
      statsPanel: document.getElementById('statsPanel'),
      statTotalChars: document.getElementById('statTotalChars'),
      statTotalPlays: document.getElementById('statTotalPlays'),
      statMostPopular: document.getElementById('statMostPopular'),
      statMostPopularValue: document.getElementById('statMostPopularValue'),
      statFastestGrowing: document.getElementById('statFastestGrowing'),
      statFastestGrowingValue: document.getElementById('statFastestGrowingValue'),
      statAvgPlays: document.getElementById('statAvgPlays'),
      comparisonSection: document.getElementById('comparisonSection'),
      comparisonSelect: document.getElementById('comparisonSelect'),
      topNSection: document.getElementById('topNSection'),
      topNSelect: document.getElementById('topNSelect'),
      rankingsSection: document.getElementById('rankingsSection'),
      rankingsList: document.getElementById('rankingsList'),
    };

    let chart;
    let autoIndex;
    let currentSeries = {};
    let currentCfg = null;

    async function loadAutoIndex() {
      const res = await fetch('auto-index.json');
      if (!res.ok) throw new Error('Failed to load auto-index.json');
      autoIndex = await res.json();
      populateConfigSelect(autoIndex.configs || []);
      // Choose default: first config with non-empty character_totals-deltas series
      const findDefault = async () => {
        for (const cfg of autoIndex.configs || []) {
          const path = cfg.paths?.character_totals_deltas;
          if (!path) continue;
          try {
            const r = await fetch(path);
            if (!r.ok) continue;
            const data = await r.json();
            if (data && data.series && Object.keys(data.series).length > 0) return cfg.slug;
          } catch {}
        }
        return autoIndex.configs?.[0]?.slug;
      };
      const defSlug = await findDefault();
      if (defSlug) {
        els.configSelect.value = defSlug;
        handleConfigChange();
      }
    }

    function populateConfigSelect(configs) {
      els.configSelect.innerHTML = '';
      for (const cfg of configs) {
        const opt = document.createElement('option');
        opt.value = cfg.slug;
        opt.textContent = (cfg.config?.split('/')?.slice(-2)?.join(' / ')) || cfg.slug;
        els.configSelect.appendChild(opt);
      }
    }

    async function handleConfigChange() {
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      els.configIcon.src = cfg.icon || '';
      els.configIcon.classList.toggle('hidden', !cfg.icon);
      els.configMeta.textContent = cfg.config || '';
      
      // Load data based on selected type
      await loadDataType();
    }
    
    async function loadDataType() {
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      
      const dataType = els.dataTypeSelect.value;
      const path = cfg.paths?.[dataType];
      let data;
      try {
        const res = await fetch(path);
        data = await res.json();
      } catch (e) {
        data = { series: {} };
      }
      const series = data?.series || {};
      populateCharacterSelect(series, cfg);
    }

    function populateCharacterSelect(series, cfg) {
      const names = Object.keys(series).sort();
      els.characterSelect.innerHTML = '';
      currentSeries = series;
      currentCfg = cfg;
      
      // Set date range based on data
      updateDateRangeLimits(series);
      
      // Also populate comparison select
      populateComparisonSelect(series);
      
      if (names.length === 0) {
        const opt = document.createElement('option');
        opt.textContent = 'No characters in this config yet';
        els.characterSelect.appendChild(opt);
        els.characterSelect.disabled = true;
        els.characterHint.textContent = 'No data available for this config yet.';
        updateChart([], cfg);
        return;
      }
      for (const name of names) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        els.characterSelect.appendChild(opt);
      }
      els.characterSelect.disabled = false;
      els.characterHint.textContent = 'Showing cumulative plays (c) over time.';
      els.characterSelect.value = names[0];
      handleCharacterChange(series, cfg);
    }

    function updateDateRangeLimits(series) {
      let minDate = null;
      let maxDate = null;
      
      for (const points of Object.values(series)) {
        for (const point of points) {
          const date = new Date(point.t);
          if (!minDate || date < minDate) minDate = date;
          if (!maxDate || date > maxDate) maxDate = date;
        }
      }
      
      if (minDate && maxDate) {
        els.startDate.min = minDate.toISOString().split('T')[0];
        els.startDate.max = maxDate.toISOString().split('T')[0];
        els.endDate.min = minDate.toISOString().split('T')[0];
        els.endDate.max = maxDate.toISOString().split('T')[0];
      }
    }

    function filterDataByDateRange(points) {
      if (!els.startDate.value && !els.endDate.value) return points;
      
      const startTime = els.startDate.value ? new Date(els.startDate.value).getTime() : -Infinity;
      const endTime = els.endDate.value ? new Date(els.endDate.value + 'T23:59:59').getTime() : Infinity;
      
      return points.filter(p => {
        const t = new Date(p.t).getTime();
        return t >= startTime && t <= endTime;
      });
    }

    function handleCharacterChange(series, cfg) {
      const name = els.characterSelect.value;
      const allPoints = (series[name] || []).slice().sort((a,b) => new Date(a.t) - new Date(b.t));
      const points = filterDataByDateRange(allPoints);
      const data = points.map(p => ({ x: new Date(p.t), y: Number(p.c ?? p.d ?? 0) }));
      updateChart(data, cfg, name);
    }

    function updateChart(data, cfg, name) {
      const viewMode = els.viewMode.value;
      
      if (viewMode === 'single') {
        updateSingleCharacterChart(data, cfg, name);
      } else if (viewMode === 'all') {
        updateAllCharactersChart(currentSeries, cfg);
      } else if (viewMode === 'allLines') {
        updateAllCharactersLineChart(currentSeries, cfg);
      } else if (viewMode === 'slope') {
        updateSlopeChart(currentSeries, cfg);
      } else if (viewMode === 'pie') {
        updatePieChart(currentSeries, cfg);
      } else if (viewMode === 'comparison') {
        updateComparisonChart(currentSeries, cfg);
      }
      
      // Update stats panel for all views
      updateStatsPanel(currentSeries, cfg);
      
      // Update rankings for comparison views
      updateRankings(currentSeries, cfg, viewMode);
    }

    function updateSingleCharacterChart(data, cfg, name) {
      els.emptyState.classList.toggle('hidden', data.length > 0);
      els.chartTitle.textContent = 'Item Plays Over Time';
      els.chartSubtitle.textContent = name ? `${name} — ${cfg?.slug || ''}` : (cfg?.slug || '');

      const gradient = (() => {
        const ctx = els.chartCanvas.getContext('2d');
        const g = ctx.createLinearGradient(0, 0, 0, 400);
        g.addColorStop(0, 'rgba(74,118,255,0.35)');
        g.addColorStop(1, 'rgba(74,118,255,0.03)');
        return g;
      })();

      const ds = {
        label: 'Plays (cumulative)',
        data,
        fill: true,
        borderColor: '#4a76ff',
        backgroundColor: gradient,
        pointRadius: 2,
        tension: 0.25,
      };

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: { datasets: [ds] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'PPpp' },
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            }
          },
          plugins: {
            legend: { labels: { color: 'rgba(255,255,255,0.8)' } },
            tooltip: {
              callbacks: {
                label: (ctx) => ` ${ctx.dataset.label}: ${ctx.parsed.y}`
              }
            }
          }
        }
      });
    }

    function updateAllCharactersChart(series, cfg) {
      els.chartTitle.textContent = 'All Items Popularity';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // Get the latest cumulative value for each character
      const characterData = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        characterData.push({ name, value: latestValue });
      }
      
      // Sort by value descending
      characterData.sort((a, b) => b.value - a.value);
      
      els.emptyState.classList.toggle('hidden', characterData.length > 0);
      
      const labels = characterData.map(d => d.name);
      const values = characterData.map(d => d.value);
      
      // Create color gradient based on popularity
      const colors = values.map((v, i) => {
        const ratio = i / Math.max(1, values.length - 1);
        const hue = 220 + (ratio * 60); // Blue to cyan gradient
        const saturation = 80 - (ratio * 30);
        const lightness = 60 - (ratio * 20);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      });

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Total Plays',
            data: values,
            backgroundColor: colors,
            borderColor: colors.map(c => c.replace('60%', '70%')),
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { 
                color: 'rgba(255,255,255,0.7)',
                font: { size: 10 }
              }
            }
          },
          plugins: {
            legend: { 
              display: false
            },
            tooltip: {
              callbacks: {
                label: (ctx) => ` Total Plays: ${ctx.parsed.x.toLocaleString()}`
              }
            }
          }
        }
      });
    }

    function updateAllCharactersLineChart(series, cfg) {
      els.chartTitle.textContent = 'All Items - Rate of Change Over Time';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // First, get top N characters by total plays
      const topN = parseInt(els.topNSelect.value) || 0;
      let charactersByPopularity = [];
      
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length < 1) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        charactersByPopularity.push({ name, value: latestValue });
      }
      
      charactersByPopularity.sort((a, b) => b.value - a.value);
      const topCharacters = topN > 0 ? charactersByPopularity.slice(0, topN).map(c => c.name) : charactersByPopularity.map(c => c.name);
      
      // Now build the line chart with only top characters
      const allTimestamps = new Set();
      const filteredSeries = {};
      
      for (const [name, allPoints] of Object.entries(series)) {
        if (!topCharacters.includes(name)) continue;
        const points = filterDataByDateRange(allPoints);
        if (points.length < 1) continue;
        filteredSeries[name] = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        filteredSeries[name].forEach(p => allTimestamps.add(p.t));
      }
      
      // Convert to sorted array
      const timestamps = Array.from(allTimestamps).sort((a, b) => new Date(a) - new Date(b));
      
      if (timestamps.length < 2) {
        els.emptyState.classList.toggle('hidden', false);
        if (chart) chart.destroy();
        return;
      }
      
      const datasets = [];
      const colorPalette = [
        '#4a76ff', '#ff6b6b', '#51cf66', '#ffd93d', '#a78bfa', 
        '#fb7185', '#60a5fa', '#34d399', '#fbbf24', '#c084fc',
        '#f472b6', '#38bdf8', '#6ee7b7', '#fdba74', '#e879f9',
        '#fb923c', '#67e8f9', '#86efac', '#fca5a5', '#d8b4fe'
      ];
      
      let colorIndex = 0;
      for (const [name, points] of Object.entries(filteredSeries)) {
        // Create a map of timestamp -> point data
        const pointMap = new Map();
        points.forEach(p => pointMap.set(p.t, p));
        
        // Fill in all timestamps, carrying forward cumulative values
        const normalizedPoints = [];
        let lastCumulative = 0;
        
        for (const timestamp of timestamps) {
          if (pointMap.has(timestamp)) {
            const point = pointMap.get(timestamp);
            lastCumulative = Number(point.c ?? lastCumulative);
            normalizedPoints.push({ t: timestamp, c: lastCumulative });
          } else {
            // Missing data point - use last cumulative value (delta = 0)
            normalizedPoints.push({ t: timestamp, c: lastCumulative });
          }
        }
        
        // Calculate rate of change with normalized data
        const rateData = [];
        for (let i = 1; i < normalizedPoints.length; i++) {
          const prevPoint = normalizedPoints[i - 1];
          const currPoint = normalizedPoints[i];
          
          const timeDiff = (new Date(currPoint.t) - new Date(prevPoint.t)) / (1000 * 60 * 60); // hours
          const valueDiff = currPoint.c - prevPoint.c;
          const rate = timeDiff > 0 ? valueDiff / timeDiff : 0; // plays per hour
          
          rateData.push({
            x: new Date(currPoint.t),
            y: rate
          });
        }
        
        if (rateData.length > 0) {
          const color = colorPalette[colorIndex % colorPalette.length];
          datasets.push({
            label: name,
            data: rateData,
            borderColor: color,
            backgroundColor: color + '20',
            borderWidth: 2,
            pointRadius: 1,
            pointHoverRadius: 4,
            tension: 0.3,
            fill: false
          });
          colorIndex++;
        }
      }
      
      els.emptyState.classList.toggle('hidden', datasets.length > 0);
      
      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'PPpp' },
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' },
              title: {
                display: true,
                text: 'Plays per Hour',
                color: 'rgba(255,255,255,0.8)'
              }
            }
          },
          plugins: {
            legend: { 
              labels: { color: 'rgba(255,255,255,0.8)', font: { size: 10 } },
              position: 'top',
              maxHeight: 100
            },
            tooltip: {
              callbacks: {
                label: (ctx) => ` ${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)} plays/hour`
              }
            }
          }
        }
      });
    }

    function updateSlopeChart(series, cfg) {
      els.chartTitle.textContent = 'Item Popularity Trends (Slope)';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // Calculate slope (growth rate) for each character
      const characterSlopes = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length < 2) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        
        // Calculate simple linear regression slope
        const n = sortedPoints.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        
        sortedPoints.forEach((point, idx) => {
          const x = idx;
          const y = Number(point.c ?? 0);
          sumX += x;
          sumY += y;
          sumXY += x * y;
          sumX2 += x * x;
        });
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const latestValue = Number(sortedPoints[sortedPoints.length - 1].c ?? 0);
        
        characterSlopes.push({ name, slope, latestValue });
      }
      
      // Sort by slope descending
      characterSlopes.sort((a, b) => b.slope - a.slope);
      
      // Apply top N filter
      const topN = parseInt(els.topNSelect.value) || 0;
      const filteredSlopes = topN > 0 ? characterSlopes.slice(0, topN) : characterSlopes;
      
      els.emptyState.classList.toggle('hidden', filteredSlopes.length > 0);
      
      const labels = filteredSlopes.map(d => d.name);
      const slopes = filteredSlopes.map(d => d.slope);
      
      // Color based on slope (positive = green, negative = red)
      const colors = slopes.map(slope => {
        if (slope > 0) {
          const intensity = Math.min(slope / Math.max(...slopes), 1);
          return `rgba(74, 222, 128, ${0.4 + intensity * 0.6})`;
        } else {
          const intensity = Math.min(Math.abs(slope) / Math.max(...slopes.map(Math.abs)), 1);
          return `rgba(248, 113, 113, ${0.4 + intensity * 0.6})`;
        }
      });

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Growth Rate (plays/datapoint)',
            data: slopes,
            backgroundColor: colors,
            borderColor: colors.map(c => c.replace(/[\d.]+\)$/, '1)')),
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { 
                color: 'rgba(255,255,255,0.7)',
                font: { size: 10 }
              }
            }
          },
          plugins: {
            legend: { 
              display: false
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const idx = ctx.dataIndex;
                  const charData = filteredSlopes[idx];
                  return [
                    ` Growth Rate: ${ctx.parsed.x.toFixed(2)} plays/point`,
                    ` Current Total: ${charData.latestValue.toLocaleString()} plays`
                  ];
                }
              }
            }
          }
        }
      });
    }

    function updatePieChart(series, cfg) {
      els.chartTitle.textContent = 'Item Market Share';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      // Get the latest cumulative value for each character
      const characterData = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        if (latestValue > 0) {
          characterData.push({ name, value: latestValue });
        }
      }
      
      // Sort by value descending
      characterData.sort((a, b) => b.value - a.value);
      
      // Apply top N filter
      const topN = parseInt(els.topNSelect.value) || 0;
      const filteredData = topN > 0 ? characterData.slice(0, topN) : characterData;
      
      els.emptyState.classList.toggle('hidden', filteredData.length > 0);
      
      const labels = filteredData.map(d => d.name);
      const values = filteredData.map(d => d.value);
      
      // Create vibrant color palette
      const colorPalette = [
        '#4a76ff', '#ff6b6b', '#51cf66', '#ffd93d', '#a78bfa', 
        '#fb7185', '#60a5fa', '#34d399', '#fbbf24', '#c084fc',
        '#f472b6', '#38bdf8', '#6ee7b7', '#fdba74', '#e879f9',
        '#fb923c', '#67e8f9', '#86efac', '#fca5a5', '#d8b4fe'
      ];
      const colors = filteredData.map((_, i) => colorPalette[i % colorPalette.length]);

      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'doughnut',
        data: {
          labels,
          datasets: [{
            label: 'Total Plays',
            data: values,
            backgroundColor: colors,
            borderColor: '#1e293b',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { 
              labels: { color: 'rgba(255,255,255,0.8)', font: { size: 10 } },
              position: 'right',
              maxHeight: 400
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const total = values.reduce((a, b) => a + b, 0);
                  const percentage = ((ctx.parsed / total) * 100).toFixed(1);
                  return ` ${ctx.label}: ${ctx.parsed.toLocaleString()} plays (${percentage}%)`;
                }
              }
            }
          }
        }
      });
    }

    function updateComparisonChart(series, cfg) {
      els.chartTitle.textContent = 'Item Comparison';
      els.chartSubtitle.textContent = cfg?.slug || '';
      
      const selectedChars = Array.from(els.comparisonSelect.selectedOptions).map(opt => opt.value);
      
      if (selectedChars.length < 2) {
        els.emptyState.classList.toggle('hidden', false);
        if (chart) chart.destroy();
        return;
      }
      
      const datasets = [];
      const colorPalette = [
        '#4a76ff', '#ff6b6b', '#51cf66', '#ffd93d', '#a78bfa', '#fb7185'
      ];
      
      selectedChars.forEach((name, idx) => {
        const allPoints = series[name] || [];
        const points = filterDataByDateRange(allPoints).slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        const data = points.map(p => ({ x: new Date(p.t), y: Number(p.c ?? p.d ?? 0) }));
        
        const color = colorPalette[idx % colorPalette.length];
        datasets.push({
          label: name,
          data,
          borderColor: color,
          backgroundColor: color + '20',
          borderWidth: 3,
          pointRadius: 3,
          pointHoverRadius: 5,
          tension: 0.3,
          fill: false
        });
      });
      
      els.emptyState.classList.toggle('hidden', datasets.length > 0);
      
      if (chart) chart.destroy();
      chart = new Chart(els.chartCanvas, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'PPpp' },
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' }
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255,255,255,0.06)' },
              ticks: { color: 'rgba(255,255,255,0.7)' },
              title: {
                display: true,
                text: 'Cumulative Plays',
                color: 'rgba(255,255,255,0.8)'
              }
            }
          },
          plugins: {
            legend: { 
              labels: { color: 'rgba(255,255,255,0.8)', font: { size: 12 } },
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: (ctx) => ` ${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} plays`
              }
            }
          }
        }
      });
    }

    function updateStatsPanel(series, cfg) {
      if (!series || Object.keys(series).length === 0) {
        els.statsPanel.classList.add('hidden');
        return;
      }
      
      els.statsPanel.classList.remove('hidden');
      
      // Calculate stats
      const characterData = [];
      const characterSlopes = [];
      
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        characterData.push({ name, value: latestValue });
        
        // Calculate slope for growth rate
        if (points.length >= 2) {
          const sortedForSlope = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
          const n = sortedForSlope.length;
          let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
          
          sortedForSlope.forEach((point, idx) => {
            const x = idx;
            const y = Number(point.c ?? 0);
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
          });
          
          const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
          characterSlopes.push({ name, slope, latestValue });
        }
      }
      
      // Total characters
      els.statTotalChars.textContent = characterData.length;
      
      // Total plays
      const totalPlays = characterData.reduce((sum, c) => sum + c.value, 0);
      els.statTotalPlays.textContent = totalPlays.toLocaleString();
      
      // Most popular
      if (characterData.length > 0) {
        characterData.sort((a, b) => b.value - a.value);
        els.statMostPopular.textContent = characterData[0].name;
        els.statMostPopularValue.textContent = characterData[0].value.toLocaleString() + ' plays';
      }
      
      // Fastest growing
      if (characterSlopes.length > 0) {
        characterSlopes.sort((a, b) => b.slope - a.slope);
        els.statFastestGrowing.textContent = characterSlopes[0].name;
        els.statFastestGrowingValue.textContent = '+' + characterSlopes[0].slope.toFixed(1) + ' plays/point';
      }
      
      // Average plays per character
      const avgPlays = characterData.length > 0 ? Math.round(totalPlays / characterData.length) : 0;
      els.statAvgPlays.textContent = avgPlays.toLocaleString();
    }

    function populateComparisonSelect(series) {
      els.comparisonSelect.innerHTML = '';
      const names = Object.keys(series).sort();
      for (const name of names) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        els.comparisonSelect.appendChild(opt);
      }
    }

    function updateRankings(series, cfg, viewMode) {
      // Show rankings for comparison views
      const shouldShowRankings = ['all', 'allLines', 'slope', 'pie'].includes(viewMode);
      els.rankingsSection.classList.toggle('hidden', !shouldShowRankings);
      
      if (!shouldShowRankings) return;
      
      // Calculate rankings by total plays
      const rankings = [];
      for (const [name, allPoints] of Object.entries(series)) {
        const points = filterDataByDateRange(allPoints);
        if (points.length === 0) continue;
        const sortedPoints = points.slice().sort((a,b) => new Date(b.t) - new Date(a.t));
        const latestValue = Number(sortedPoints[0].c ?? 0);
        
        // Calculate growth rate
        let growthRate = 0;
        if (points.length >= 2) {
          const sortedForSlope = points.slice().sort((a,b) => new Date(a.t) - new Date(b.t));
          const n = sortedForSlope.length;
          let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
          
          sortedForSlope.forEach((point, idx) => {
            const x = idx;
            const y = Number(point.c ?? 0);
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
          });
          
          growthRate = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        }
        
        rankings.push({ name, plays: latestValue, growthRate });
      }
      
      // Sort by plays descending
      rankings.sort((a, b) => b.plays - a.plays);
      
      // Apply top N filter if available
      const topN = parseInt(els.topNSelect.value) || 0;
      const displayRankings = topN > 0 ? rankings.slice(0, topN) : rankings.slice(0, 20);
      
      // Update rankings display
      els.rankingsList.innerHTML = '';
      displayRankings.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'flex items-center justify-between p-2 bg-slate-800/50 rounded text-xs';
        
        const rankBadge = document.createElement('span');
        rankBadge.className = 'flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center font-bold text-xs ' +
          (idx === 0 ? 'bg-yellow-500 text-slate-900' : 
           idx === 1 ? 'bg-gray-400 text-slate-900' :
           idx === 2 ? 'bg-amber-600 text-slate-900' :
           'bg-slate-700 text-slate-300');
        rankBadge.textContent = idx + 1;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'flex-1 mx-2 truncate';
        nameSpan.textContent = item.name;
        
        const playsSpan = document.createElement('span');
        playsSpan.className = 'text-brand-400 font-mono';
        playsSpan.textContent = item.plays.toLocaleString();
        
        const growthSpan = document.createElement('span');
        growthSpan.className = 'ml-2 ' + (item.growthRate >= 0 ? 'text-green-400' : 'text-red-400');
        growthSpan.textContent = (item.growthRate >= 0 ? '+' : '') + item.growthRate.toFixed(1);
        
        div.appendChild(rankBadge);
        div.appendChild(nameSpan);
        div.appendChild(playsSpan);
        div.appendChild(growthSpan);
        els.rankingsList.appendChild(div);
      });
    }

    // Events
    els.configSelect.addEventListener('change', handleConfigChange);
    els.dataTypeSelect.addEventListener('change', loadDataType);
    els.characterSelect.addEventListener('change', () => {
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      fetch(cfg.paths.character_totals_deltas)
        .then(r => r.json())
        .then(data => handleCharacterChange(data.series || {}, cfg));
    });
    
    els.viewMode.addEventListener('change', () => {
      const viewMode = els.viewMode.value;
      els.singleCharacterSection.style.display = viewMode === 'single' ? 'block' : 'none';
      els.comparisonSection.style.display = viewMode === 'comparison' ? 'block' : 'none';
      els.topNSection.style.display = (viewMode === 'allLines' || viewMode === 'slope' || viewMode === 'pie') ? 'block' : 'none';
      
      const slug = els.configSelect.value;
      const cfg = (autoIndex.configs || []).find(c => c.slug === slug);
      if (!cfg) return;
      
      if (viewMode === 'single') {
        // Reload current character
        const name = els.characterSelect.value;
        const allPoints = (currentSeries[name] || []).slice().sort((a,b) => new Date(a.t) - new Date(b.t));
        const points = filterDataByDateRange(allPoints);
        const data = points.map(p => ({ x: new Date(p.t), y: Number(p.c ?? p.d ?? 0) }));
        updateChart(data, cfg, name);
      } else {
        // Show all characters or other views
        updateChart([], cfg);
      }
    });
    
    els.comparisonSelect.addEventListener('change', () => {
      if (currentCfg && els.viewMode.value === 'comparison') {
        updateChart([], currentCfg);
      }
    });
    
    els.topNSelect.addEventListener('change', () => {
      if (currentCfg) {
        updateChart([], currentCfg);
      }
    });
    
    els.startDate.addEventListener('change', () => {
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });
    
    els.endDate.addEventListener('change', () => {
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });
    
    els.resetDateRange.addEventListener('click', () => {
      els.startDate.value = '';
      els.endDate.value = '';
      if (currentCfg) {
        const viewMode = els.viewMode.value;
        if (viewMode === 'single') {
          handleCharacterChange(currentSeries, currentCfg);
        } else {
          updateChart([], currentCfg);
        }
      }
    });

    // Init
    loadAutoIndex().catch(err => {
      console.error(err);
      els.configSelect.innerHTML = '<option>Failed to load auto-index.json</option>';
    });
  </script>
</body>
</html>
